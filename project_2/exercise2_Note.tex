\documentclass[11pt, notitlepage]{scrartcl}
\usepackage{graphicx}    % needed for including graphics e.g. EPS, PS
\usepackage{amsmath}
\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\usepackage[german]{babel}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{booktabs} % for midrule
\usepackage{colortbl}
\usepackage{color}
\usepackage{hyperref}
\definecolor{Gray}{gray}{0.6}

\usepackage{tabularx}          
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}} 
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}p{#1}} 

\addtokomafont{captionlabel}{\bfseries} %references bf

\topmargin -1.5cm        % read Lamport p.163
\oddsidemargin -0.04cm   % read Lamport p.163
\evensidemargin -0.04cm  % same as oddsidemargin but for left-hand pages
\textwidth 16.59cm
\textheight 24cm 
\parskip 7.2pt           % sets spacing between paragraphs
\parindent 0pt     % sets leading space for paragraphs

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}



%\renewcommand{\headrulewidth}{0.5pt}
%\fancyfoot[C]{\thepage}
%\renewcommand{\footrulewidth}{0.5pt}
% folder for images
%\graphicspath{{./img/}}
\begin{document}         


\title{Advanced Algorithms for Bioinformatics} 
\subtitle{Exercise 2: Read mapping with QUASAR}
%\author{ }
%\author{}
\author{Group 5: N. G"uttler, K. Liebers, F. Mattes} % lexicogrphic sorted
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%\textbf{q-gram index}\\
The program was implemented pretty much according to the indications given during the exercises. The bases A,C,G and T were encoded as integer numbers 0,1,2 and 3 respectively.

Doing so the $4^q$ permutations of a sequence of length $q$, can be computed and accessed using their numerical representation.\\ 
Instead of creating a suffix array for compute/store the start positions of the permutations occurrences, the genome was scanned and the number of occurrences of the found permutation was determine.

When a new base at the genome is read, the bit representation of  its assigned integer number was calculated and added to the bit array of length $2q$. The integer number (encoded by q-positions) was then established and the counter of the corresponding permutation was increased. 
No q-gram table as depicted in script was created, since the integer representation (q-gram index) was enough for all computations.\\ 
Instead of two scans of the genome to fill a table of the size \textit{genome length - q +1}, the genome was scanned only once and the start positions of the occurrences were stored in a vector of vectors of length $4^q$.

For the bit representation of numbers the associative container \textit{'bitset'} was chosen. Since its constructor requires a constant parameter at compile time, a maximal value for q, Q=12 was defined. Then depending on the given q the bit representation was appropriately adapted. 
See code for more details.   

\textbf{Blocking}\\
According to the minimal block length, which amounts at least to read length + k, the number of blocks was calculated with: $\lfloor$ genome size/minimal block length$\rfloor$. The limits of each block were first determined without overlap and then expanded to the left and/or right so that the minimum overlap between blocks \textit{(read length + k -1)} was achieved.

\textbf{Matching}\\
The reads were scanned in a similar way to the genome. For each q-gram its permutation id was computed and afterwards checked, whether this permutation occurs on the genome or not. Simply by accessing the vector table (occurrences) at position permutation id and determining the size of the vector.\\
On the basis of the start position the possibly block number can be calculated. Then if the q-gram start and end positions lie between the block's range, its counter was incremented. The possible occurrence in adjacent blocks (left and right) were also checked, for the case that the q-gram lies in a block-overlap.

Finally, the semi-global aligner from exercise1 was used for the verification of the blocks with a counter value greater/equal the computed threshold. For this, a slightly adaptation of the function 'fastUkkonen' was effectuated in order to search in the genome only between the block's limits. 

% #######################################################################################
\section{Results/Observations}
\subsection{Comparison with the runtime from Exercise 1}
In order to show the impact of filtering, the program 'exercise2.cpp' was executed with the same parameters as 'exercise1' ($k=0$, Ukkonen trick = on) and the block length was set to be equal to the read length. After a few tries with different values for the q-gram length, $q=8$ was chosen since it seemed to be suitable for all data sets.

The following table shows the new  ($3^{rd}$ row) and old runtimes.


\begin{center}
\begin{tabular}{c|c|c||c|c|c}
\toprule
\multirow{2}*{Reads file's name} &  \multicolumn{3}{c|}{Running time [sec]}& \multirow{2}*{Nr. of occurrences} & Nr. of verifications\\
\cline{2-4}
&exercise1.cpp& exercise2.cpp & Razers&&(in exercise2.cpp)\\
\hline
{50\_100}&13.60&\textbf{1.49} &11.79 &31&31\\

\hline
{50\_1k}& 136.47& \textbf{2.47}&12.42&289&289\\
 \hline
100\_100& 13.79&\textbf{1.54}&11.95&16&16\\

\hline
100\_1k&136.68 &\textbf{2.72}&13.23&189&190\\
 \hline
400\_100& 15.66&\textbf{1.61}&12.24 &11&13\\
\hline
400\_1k& 137.23&\textbf{3.63}&16.19 &54&72\\
\bottomrule
\end{tabular}
\end{center}

Program 'exercise2' was executed on the same linux machine \textit{andorra}\footnote{andorra.imp.fu-berlin.de} as 'exercise1' so that the remarkably reduction of the runtime is based only on the filtering process. The number of the semi-global aligner calls, i.e., the number of verifications was in the most cases equal to the number of occurrences. 

Setting $q=9$ the number of verification for the last data set is reduced from 72 to 55, reducing also the runtime to $3.47s$. For the other cases, where the number of verifications is already equal to the number of occurrences, an increase of the value of $q$ do not improve the runtime but slows down the procedure, since the number of permutations of a string of the length $q$ increase exponentially. E.g. with $q=9$ the program's runtime on the first data set amounts to $2.70s$.



\subsection{Larger datasets}
Test different values of $k$, $q$ and $b$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
