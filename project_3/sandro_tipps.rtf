{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww25100\viewh15040\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\fs24 \cf0 Suffix array sortieren\
\
Move-to-front encoding (Pseudo Algo aus dem Skript hernehmen, wie es dort steht)\
\
Wir haben dann den Array R\
\
Huffman Code erzeugen. Tree bauen. Algorithmus suchen und implementieren. Entweder Baum implementieren oder ne Array oder ne Map. Uns \'fcberlassen.\
\
Huffeman Code einfach rausschreiben. Das wars.\
\
R\'fcckw\'e4rts: Parsen\
\
Huffman Code zur\'fcckschreiben.\
\
Move-to-front r\'fcckw\'e4rts\
\
L-to-F Mapping: Wir brauchen C und Occ als Hilfe. C beinhaltet f\'fcr einen Buchstaben die Anzahl der Buchstaben, die im Text vorkommen und lexikographisch kleiner sind. Daf\'fcr einfach durch den BWT gehen und z\'e4hlen, da BWT der gesamte Text ist.\
Occ auch linearer Scan durch BWT.\
\
Damit ist das Reverse Construct fertig.\
\
Backward Search wird garnicht gebraucht.\
\
vector<int> suftab;\
std:sort(suftab.begin(), suftab.end(), MyCompTIme(index1, index2, completeString));}