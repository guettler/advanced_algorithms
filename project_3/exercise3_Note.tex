\documentclass[11pt, notitlepage]{scrartcl}
\usepackage{graphicx}    % needed for including graphics e.g. EPS, PS
\usepackage{amsmath}
\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\usepackage[german]{babel}
\usepackage{subfigure}
\usepackage{multirow} 
\usepackage{multicol}
\usepackage{booktabs} % for midrule
\usepackage{colortbl}
\usepackage{color}
\usepackage{hyperref}
\definecolor{Gray}{gray}{0.6}

\usepackage{tabularx}          
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}} 
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}p{#1}} 

\addtokomafont{captionlabel}{\bfseries} %references bf

\topmargin -1.5cm        % read Lamport p.163
\oddsidemargin -0.04cm   % read Lamport p.163
\evensidemargin -0.04cm  % same as oddsidemargin but for left-hand pages
\textwidth 16.59cm
\textheight 24cm 
\parskip 7.2pt           % sets spacing between paragraphs
\parindent 0pt     % sets leading space for paragraphs

%\usepackage{fancyhdr}
%\pagestyle{fancy}
%\fancyhf{}



%\renewcommand{\headrulewidth}{0.5pt}
%\fancyfoot[C]{\thepage}
%\renewcommand{\footrulewidth}{0.5pt}
% folder for images
%\graphicspath{{./img/}}
\begin{document}         


\title{Advanced Algorithms for Bioinformatics} 
\subtitle{Exercise 3: Compression with BWT}
%\author{ }
%\author{}
\author{Group 5: N. G"uttler, K. Liebers, F. Mattes} % lexicogrphic sorted
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%\textbf{q-gram index}\\


Tasks: (nur als Anhaltspunkte, d.h. am Ende weg damit!)

Mode c
\begin{itemize}
	\item   reads a single sequence from a fasta file
	   \item calculates the BWT of that sequence
    \item implements move-to-front encoding and Huffman coding to compress the BWT
    writes the Huffman code into an outfile 
	
\end{itemize}

Mode x
\begin{itemize}
	\item     reads a file containing the BWT compression of some sequence
	\item writes the uncompressed sequence into a fasta outfile. 
\end{itemize}

\textbf{Short introduction (TBD by?)}\\
\subsection{Mode c}




  
\textbf{BWT and move-to-front (short: 2-3 sentences TBD by Kurt)}\\
Skew7 from seqAn and algorithm as in script. Nothing special therefore only mention it and warn, that on linux we could not import seqan, therefore it could be problems by compiling.


\textbf{Huffman code: TBD by Kurt}\\
-Description of the used data structures and how to get the pathway(bitcode) of the characters i.e. leafs.\\
-outputfile?: 1-2 sentences

% #######################################################################################
\subsection{Mode x}
\subsubsection{Huffman Code -> R Decoding}
short description 2-3 sentences TBD by Kurt, may be unnecessary.
\subsubsection{L-to-F-Mapping aka BWT to Original Text Decoding}
This is the last reversion step to create the original text. We are given the BWT representation of the original text
from the decoding move-to-front step. So basically it's a mutated order of the original text. \\\\
The decoding step of our program makes use of the core obersation mentioned in the lecture script - observation 9. The
observation states that the RELATIVE order of two cyclic shifts ending with the same character is preserved. In other
words:
THe character in 'L' from the last cyclic shift is appearing are the character in 'F' in the next shift. Following this
fact, we can say that a sequence of the same character in the given 'L' is the same sequence of this character in 'F',
only starting at different points. Using those observations what we are really doing is: 
\begin{itemize}
    \item For every character in the alphabet count the number of character lexicographically smaller than the character
    appearing in 'L'.
    \item For every character in the alphabet we also count the number of its occurrences in 'L'.
    \item Both previously mentioned values are stored in a list called 'C'
    \item As a second step the list 'Occ' contains for a certain position in 'L' the number of occurrences of each
    character of the alphabet up to that position.
    \item Having both lists, the 'LF' function can be calculated like this: LF(i) = C(L[i]) + Occ(L[i],i)
\end{itemize}
The method for this decoding step is called 'lfMapping' in our code. Unfornuately we weren't able to complete the
implementation of this method. This is what's missing for us to complete the 'x' mode and decode everything. The
implementation - so far - is given in the code.
\subsubsection{Move-to-Front Decoding}
This is the reversion step from the move-to-front encoding. The goal is to get the BWT representation of the original
text, given the encoded sequence of integers. Also given from the stored file is the alphabet of which the BWT and the
original text consisted of. \\\\
In principle the reversion is the same core procedure as the encoding step. We are using the sequence of integers -
denoted as 'R' in the lecture script - which contains the spots of the alphabet to be taken. Having one spot of the
alphbet we pick that one and move the char to the sequence of chars to be created. This new sequence is our developing
decoded 'L' or the BWT sequence. Afterwards we move the selected char to the front of the alphabet sequence - like in
the encoding step - and move one position to the right in our given integer stream. Done. \\\\
In our code this decoding method is called 'moveToFrontDecoding'.
% #######################################################################################
\section{Results/Observations}
\subsection*{Comparison of the compression rate}
The goal of this programming assignment was to create a program able to transform a given text - e.g. a genome - into a
datastructure with which search operations are still possible. The first step in this transformation is to create a
suffix array and then create a BWT representation form it. After that, the task was to also compress this representation
and store it to the hard-drive to save disk space. Compression was conducted in two steps:
\begin{enumerate}
    \item Using move-to-front encoding to create a sequence of integers instead of chars to save space.
    \item Using Huffman encoding to optimize bit usage for the integer sequence from step 1.
\end{enumerate}
Encoding and compressed results are stored to the hard disk.\\\\
On the other hand, the invert route was constructed, too. The program in mode `x` is able to read in the binary
compressed file with the data. Using the data all steps (compression and encoding) are reverted and the result is
checked for test purposes. \\\\
In the following we present an overview of the compression of our program and wide-spread compression tools. This way
effectiveness is checked and compared. \\\\
\begin{center}
\begin{tabular}{c|c|c|}
\toprule
\multirow{2}*{Method's name} &  \multirow{2}*{Original file size} & \multirow{2}*{Compressed file size} \\
\hline
{Assignment program} & 9.7 MB & 0.0 MB\\
\hline
{WinZIP} & 9.7 MB & 0.0 MB \\
\hline
{bzip2} & 9.7 MB & 2.8 MB \\
\bottomrule
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
